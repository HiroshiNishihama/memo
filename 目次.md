# Part 1: Input/Output Logical  
# Table of Contents  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Features of the Input/Output Specification  
1.3.1 Functional Features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
# Chapter 2  System Models  
2.1 Introduction  
2.2 Processing Element Models  
2.2.1 Processor-Memory Processing Element Model  
2.2.2 Integrated Processor-Memory Processing Element Model   
2.2.3 Memory-Only Processing Element Model   
2.2.4 Processor-Only Processing Element  
2.2.5 I/O Processing Element   
2.2.6 Switch Processing Element  
2.3 System Issues  
2.3.1 Operation Ordering  
2.3.2 Transaction Delivery  
2.3.2.1 Unordered Delivery System Issues  
2.3.2.2 Ordered Delivery System Issues  
2.3.3 Deadlock Considerations  
# Chapter 3  Operation Descriptions  
3.1 Introduction  
3.2 I/O Operations Cross Reference   
3.3 I/O Operations  
3.3.1 Read Operations  
3.3.2 Write and Streaming-Write Operations  
3.3.3 Write-With-Response Operations  
3.3.4 Atomic (Read-Modify-Write) Operations   
3.4 System Operations   
3.4.1 Maintenance Operations   
3.5 Endian, Byte Ordering, and Alignment   
# Chapter 4  Packet Format Descriptions  
4.1 Request Packet Formats  
4.1.1 Addressing and Alignment   
4.1.2 Field Definitions for All Request Packet Formats  
4.1.3 Type 0 Packet Format (Implementation-Defined)  
4.1.4 Type 1 Packet Format (Reserved)   
4.1.5 Type 2 Packet Format (Request Class)  
4.1.6 Type 3–4 Packet Formats (Reserved)  
4.1.7 Type 5 Packet Format (Write Class)  
4.1.8 Type 6 Packet Format (Streaming-Write Class)  
4.1.9 Type 7 Packet Format (Reserved)   
4.1.10 Type 8 Packet Format (Maintenance Class)  
4.1. Type 9– Packet Formats (Reserved)  
4.2 Response Packet Formats   
4.2.1 Field Definitions for All Response Packet Formats   
4.2.2 Type 12 Packet Format (Reserved)   
4.2.3 Type 13 Packet Format (Response Class)   
4.2.4 Type 14 Packet Format (Reserved)   
4.2.5 Type 15 Packet Format (Implementation-Defined)  
# Chapter 5  Input/Output Registers  
5.1 Register Summary  
5.2 Reserved Register, Bit and Bit Field Value Behavior   
5.3 Extended Features Data Structure  
5.4 Capability Registers (CARs)   
5.4.1 Device Identity CAR  
(Configuration Space Offset 0x0)  
5.4.2 Device Information CAR  
(Configuration Space Offset 0x4)  
5.4.3 Assembly Identity CAR  
(Configuration Space Offset 0x8)  
5.4.4 Assembly Information CAR  
(Configuration Space Offset 0xC)  
5.4.5 Processing Element Features CAR  
(Configuration Space Offset 0x10)  
5.4.6 Switch Port Information CAR  
(Configuration Space Offset 0x14)  
5.4.7 Source Operations CAR  
(Configuration Space Offset 0x18)  
5.4.8 Destination Operations CAR  
(Configuration Space Offset 0x1C)  
5.5 Command and Status Registers (CSRs)  
5.5.1 Processing Element Logical Layer Control CSR  
(Configuration Space Offset 0x4C)  
# Part 2: Message Passing Logical   
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Features of the Message Passing Specification   
1.3.1 Functional Features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
# Chapter 2  System Models  
2.1 Introduction  
2.2 Processing Element Models  
2.2.1 Processor-Memory Processing Element Model  
2.2.2 Integrated Processor-Memory Processing Element Model   
2.2.3 Memory-Only Processing Element Model   
2.2.4 Processor-Only Processing Element  
2.2.5 I/O Processing Element   
2.2.6 Switch Processing Element  
2.3 Message Passing System Model  
2.3.1 Data Message Operations   
2.3.2 Doorbell Message Operations  
2.4 System Issues  
2.4.1 Operation Ordering  
2.4.2 Transaction Delivery  
2.4.3 Deadlock Considerations  
# Chapter 3  Operation Descriptions  
3.1 Introduction  
3.2 Message Passing Operations Cross Reference   
3.3 Message Passing Operations  
3.3.1 Doorbell Operations  
3.3.2 Data Message Operations   
3.4 Endian, Byte Ordering, and Alignment   
# Chapter 4  Packet Format Descriptions  
4.1 Introduction  
4.2 Request Packet Formats  
4.2.1 Field Definitions for All Request Packet Formats  
4.2.2 Type 0 Packet Format (Implementation-Defined)  
4.2.3 Type 1–9 Packet Formats (Reserved)  
4.2.4 Type 10 Packet Formats (Doorbell Class)  
4.2.5 Type 11 Packet Format (Message Class)  
4.3 Response Packet Formats   
4.3.1 Field Definitions for All Response Packet Formats   
4.3.2 Type 12 Packet Format (Reserved)   
4.3.3 Type 13 Packet Format (Response Class)   
4.3.4 Type 14 Packet Format (Reserved)   
4.3.5 Type 15 Packet Format (Implementation-Defined)  
# Chapter 5  Message Passing Registers  
5.1 Introduction  
5.2 Register Summary  
5.3 Reserved Register, Bit and Bit Field Value Behavior   
5.4 Capability Registers (CARs)   
5.4.1 Source Operations CAR (Configuration Space Offset 0x18)  
5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C)  
5.5 Command and Status Registers (CSRs)  
0.1 Introduction  
0.2 Definitions and Goals   
0.3 Message Operations  
0.4 Inbound Mailbox Structure  
0.4.1 Simple Inbox  
0.4.2 Extended Inbox  
0.4.3 Received Messages  
0.5 Outbound Message Queue Structure   
0.5.1 Simple Outbox  
0.5.2 Extended Outbox   
# Part 3: Common Transport  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Transport Layer Features  
1.3.1 Functional Features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
# Chapter 2  Transport Format Description  
2.1 Introduction  
2.2 System Topology   
2.2.1 Switch-Based Systems  
2.2.2 Ring-Based Systems   
2.3 System Packet Routing   
2.4 Field Alignment and Definition  
2.5 Routing Maintenance Packets  
# Chapter 3  Common Transport Registers  
3.1 Introduction  
3.2 Register Summary  
3.3 Reserved Register, Bit and Bit Field Value Behavior   
3.4 Capability Registers (CARs)   
3.4.1 Processing Element Features CAR (Configuration Space Offset 0x10)   
3.4.2 Switch Route Table Destination ID Limit CAR  
(Configuration Space Offset 0x34)  
3.5 Command and Status Registers (CSRs)  
3.5.1 Base Device ID CSR (Configuration Space Offset 0x60)  
3.5.2 Host Base Device ID Lock CSR (Configuration Space Offset 0x68)  
3.5.3 Component Tag CSR (Configuration Space Offset 0x6C)  
3.5.4 Standard Route Configuration Destination ID Select CSR  
(Configuration Space Offset 0x70)  
3.5.5 Standard Route Configuration Port Select CSR  
(Configuration Space Offset 0x74)  
3.5.6 Standard Route Default Port CSR (Configuration Space Offset 0x78)  
# Part 4: Physical Layer 8/16 LP-LVDS  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Features of the Input/Output Specification  
1.3.1 Functional features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
# Chapter 2  Physical Layer Protocol  
2.1 Introduction  
2.2 Packet Exchange Protocol   
2.2.1 Packet and Control Alignment  
2.2.2 Acknowledge Identification  
2.3 Field Placement and Definition   
2.3.1 Flow Control Fields Format  
2.3.2 Packet Priority and Transaction Request Flows   
2.3.3 Transaction and Packet Delivery  
2.3.3.1 Transaction and Packet Delivery Ordering Rules   
2.3.3.2 Deadlock Avoidance  
2.3.4 Resource Allocation  
2.3.4.1 Receiver-Controlled Flow Control   
2.3.4.2 Transmitter-Controlled Flow Control  
2.3.4.3 Receive Buffer Management   
2.3.4.4 Effective Number of Free Receive Buffers   
2.3.4.5 Speculative Packet Transmission   
2.3.5 Flow Control Mode Negotiation  
2.4 Error Detection and Recovery   
2.4.1 Control Symbol Protection   
2.4.2 Packet Protection   
2.4.3 Lost Packet Detection  
2.4.4 Implementation Note: Transactional Boundaries   
2.4.5 Link Behavior Under Error  
2.4.5.1 Recoverable Errors   
2.4.5.1.1 Packet Errors  
2.4.5.1.2 Control Symbol Errors  
2.4.5.1.3 Indeterminate errors  
2.4.5.1.4 Timeout Error   
2.4.6 CRC Operation   
2.4.7 CRC Code  
2.5 Maximum Packet Size   
2.6 Link Maintenance Protocol  
2.6.1 Command Descriptions  
2.6.1.1 Reset and Safety Lockouts  
2.6.1.2 Input-status   
2.6.1.3 Send-training  
2.6.2 Status Descriptions   
# Chapter 3  Packet and Control Symbol Transmission  
3.1 Introduction  
3.2 Packet Start and Control Symbol Delineation   
3.3 Packet Termination  
3.4 Packet Pacing  
3.5 Embedded Control Symbols   
3.6 Packet to Port Alignment  
3.7 System Maintenance  
3.7.1 Port and Link Initialization  
3.7.1.1 Sampling Window Alignment   
3.7.1.1.1 Port Width Mode Selection   
3.7.1.1.2 Input Sampling Window Alignment  
3.7.1.1.3 Training Pattern   
3.7.1.1.4 Training Pattern Transmission  
3.7.1.1.5 Ports Not Requiring Port Initialization  
3.7.1.1.6 Ports Requiring Port Initialization  
3.7.1.1.7 Port Initialization Process  
3.7.1.2 Link Initialization   
3.7.1.3 Maintenance Training  
3.7.1.4 Unexpected Training Pattern Reception  
3.7.2 Multicast-Event  
3.8 Power Management   
# Chapter 4  Control Symbol Formats  
4.1 Introduction  
4.2 Acknowledgment Control Symbol Formats   
4.2.1 Packet-Accepted Control Symbol  
4.2.2 Packet-Retry Control Symbol  
4.2.3 Packet-Not-Accepted Control Symbol   
4.2.4 Canceling Packets  
4.3 Packet Control Symbol Formats  
4.4 Link Maintenance Control Symbol Formats   
4.5 Reserved Symbol Formats  
4.6 Implementation-defined Symbol Formats   
4.7 Control Symbol to Port Alignment  
# Chapter 5   8/16 LP-LVDS Registers  
5.1 Introduction  
5.2 Register Map  
5.3 Reserved Register, Bit and Bit Field Value Behavior   
5.4 Capability Registers (CARs)   
5.4.1 Processing Element Features CAR (Configuration Space Offset 0x10)   
5.5 Generic End Point Devices  
5.5.1 Register Map  
5.5.2 Command and Status Registers (CSRs)   
5.5.2.1 8/16 LP-LVDS Register Block Header (Block Offset 0x0)   
5.5.2.2 Port Link Timeout Control CSR (Block Offset 0x20)  
5.5.2.3 Port Response Timeout Control CSR (Block Offset 0x24)  
5.5.2.4 Port General Control CSR (Block Offset 0x3C)   
5.5.2.5 Port n Error and Status CSRs (Block Offsets 0x58, 78,   
5.5.2.6 Port n Control CSR (Block Offsets 0x5C, 7C,   
5.6 Generic End Point Devices, software assisted error recovery option  
5.6.1 Register Map  
5.6.2 Command and Status Registers (CSRs)   
5.6.2.1 8/16 LP-LVDS Register Block Header (Block Offset 0x0)   
5.6.2.2 Port Link Timeout Control CSR (Block Offset 0x20)  
5.6.2.3 Port Response Timeout Control CSR (Block Offset 0x24)  
5.6.2.4 Port General Control CSR (Block Offset 0x3C)   
5.6.2.5 Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60,   
5.6.2.6 Port n Link Maintenance Response CSRs  
(Block Offsets 0x44, 64,   
5.6.2.7 Port n Local ackID Status CSRs (Block Offsets 0x48, 68,   
5.6.2.8 Port n Error and Status CSRs (Block Offsets 0x58, 78,   
5.6.2.9 Port n Control CSR (Block Offsets 0x5C, 7C,   
5.7 Generic End Point Free Devices  
5.7.1 Register Map  
5.7.2 Command and Status Registers (CSRs)   
5.7.2.1 8/16 LP-LVDS Register Block Header (Block Offset 0x0)   
5.7.2.2 Port Link Timeout Control CSR (Block Offset 0x20)  
5.7.2.3 Port General Control CSR (Block Offset 0x3C)   
5.7.2.4 Port n Error and Status CSRs (Block Offsets 0x58, 78,   
5.7.2.5 Port n Control CSR (Block Offsets 0x5C, 7C,   
5.8 Generic End Point Free Devices, software assisted error recovery option  
5.8.1 Register Map  
5.8.2 Command and Status Registers (CSRs)   
5.8.2.1 8/16 LP-LVDS Register Block Header (Block Offset 0x0)   
5.8.2.2 Port Link Timeout Control CSR (Block Offset 0x20)  
5.8.2.3 Port General Control CSR (Block Offset 0x3C)   
5.8.2.4 Port n Link Maintenance Request CSRs  
(Block Offsets 0x40, 60,   
5.8.2.5 Port n Link Maintenance Response CSRs  
(Block Offsets 0x44, 64,   
5.8.2.6 Port n Local ackID Status CSRs (Block Offsets 0x48, 68,   
5.8.2.7 Port n Error and Status CSRs (Block Offsets 0x58, 78,   
5.8.2.8 Port n Control CSR (Block Offsets 0x5C, 7C,   
# Chapter 6  System Clocking Considerations  
6.1 Introduction  
6.2 Example Clock Distribution   
6.3 Elasticity Mechanism  
# Chapter 7  Board Routing Guidelines  
7.1 Introduction  
7.2 Impedance  
7.3 Skew  
7.4 PCB Stackup  
7.5 Termination  
7.6 Additional Considerations   
7.6.1 Single Board Environments  
7.6.2 Single Connector Environments  
7.6.3 Backplane Environments  
7.7 Recommended pin escape ordering   
# Chapter 8  Signal Descriptions  
8.1 Introduction  
8.2 Signal Definitions   
8.3 RapidIO Interface Diagrams  
# Chapter 9  Electrical Specifications  
9.1 Introduction  
9.2 Overview  
9.3 DC Specifications   
9.4 AC Specifications   
9.4.1 Concepts and Definitions  
9.4.2 Driver Specifications   
9.4.3 Receiver Specifications  
# Annex A   Interface Management (Informative)  
A.1 Introduction  
A.2 Link Initialization and Maintenance Mechanism   
A.2.1 Input port training state machine   
A.2.2 Output port training state machine  
A.3 Packet Retry Mechanism   
A.3.1 Input port retry recovery state machine  
A.3.2 Output port retry recovery state machine   
A.4 Error Recovery  
A.4.1 Input port error recovery state machine  
A.4.2 Output port error recovery state machine   
# Part 5: Globally Shared Memory Logical  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.2.1 Memory System  
1.3 Features of the Globally Shared Memory Specification  
1.3.1 Functional Features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
# Chapter 2  System Models  
2.1 Introduction  
2.2 Processing Element Models  
2.2.1 Processor-Memory Processing Element Model  
2.2.2 Integrated Processor-Memory Processing Element Model   
2.2.3 Memory-Only Processing Element Model   
2.2.4 Processor-Only Processing Element  
2.2.5 I/O Processing Element   
2.2.6 Switch Processing Element  
2.3 Programming Models   
2.3.1 Globally Shared Memory System Model   
2.3.1.1 Software-Managed Cache Coherence Programming Model   
2.4 System Issues  
2.4.1 Operation Ordering  
2.4.2 Transaction Delivery  
2.4.3 Deadlock Considerations  
# Chapter 3  Operation Descriptions  
3.1 Introduction  
3.2 GSM Operations Cross Reference  
3.3 GSM Operations   
3.3.1 Read Operations  
3.3.2 Instruction Read Operations   
3.3.3 Read-for-Ownership Operations  
3.3.4 Data Cache Invalidate Operations   
3.3.5 Castout Operations  
3.3.6 TLB Invalidate-Entry Operations  
3.3.7 TLB Invalidate-Entry Synchronization Operations  
3.3.8 Instruction Cache Invalidate Operations  
3.3.9 Data Cache Flush Operations   
3.3.10 I/O Read Operations   
3.4 Endian, Byte Ordering, and Alignment   
# Chapter 4  Packet Format Descriptions  
4.1 Introduction  
4.2 Request Packet Formats  
4.2.1 Addressing and Alignment   
4.2.2 Data Payloads   
4.2.3 Field Definitions for All Request Packet Formats  
4.2.4 Type 0 Packet Format (Implementation-Defined)  
4.2.5 Type 1 Packet Format (Intervention-Request Class)  
4.2.6 Type 2 Packet Format (Request Class)  
4.2.7 Type 3–4 Packet Formats (Reserved)  
4.2.8 Type 5 Packet Format (Write Class)  
4.2.9 Type 6–11 Packet Formats (Reserved)  
4.3 Response Packet Formats   
4.3.1 Field Definitions for All Response Packet Formats   
4.3.2 Type 12 Packet Format (Reserved)   
4.3.3 Type 13 Packet Format (Response Class)   
4.3.4 Type 14 Packet Format (Reserved)   
4.3.5 Type 15 Packet Format (Implementation-Defined)  
# Chapter 5  Globally Shared Memory Registers  
5.1 Introduction  
5.2 Register Summary  
5.3 Reserved Register, Bit and Bit Field Value Behavior   
5.4 Capability Registers (CARs)   
5.4.1 Source Operations CAR (Configuration Space Offset 0x18)  
5.4.2 Destination Operations CAR (Configuration Space Offset 0x1C)  
5.5 Command and Status Registers (CSRs)  
# Chapter 6  Communication Protocols  
6.1 Introduction  
6.2 Definitions   
6.2.1 General Definitions  
6.2.2 Request and Response Definitions   
6.2.2.1 System Request  
6.2.2.2 Local Request   
6.2.2.3 System Response   
6.2.2.4 Local Response  
6.3 Operation to Protocol Cross Reference   
6.4 Read Operations  
6.4.1 Internal Request State Machine  
6.4.2 Response State Machine  
6.4.3 External Request State Machine  
6.5 Instruction Read Operations   
6.5.1 Internal Request State Machine  
6.5.2 Response State Machine  
6.5.3 External Request State Machine  
6.6 Read for Ownership Operations   
6.6.1 Internal Request State Machine  
6.6.2 Response State Machine  
6.6.3 External Request State Machine  
6.7 Data Cache and Instruction Cache Invalidate Operations   
6.7.1 Internal Request State Machine  
6.7.2 Response State Machine  
6.7.3 External Request State Machine  
6.8 Castout Operations  
6.8.1 Internal Request State Machine  
6.8.2 Response State Machine  
6.8.3 External Request State Machine  
6.9 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations  
6.9.1 Internal Request State Machine  
6.9.2 Response State Machine  
6.9.3 External Request State Machine  
6.10 Data Cache Flush Operations   
6.10.1 Internal Request State Machine  
6.10.2 Response State Machine  
6.10.3 External Request State Machine  
6.11 I/O Read Operations   
6.11.1 Internal Request State Machine  
6.11.2 Response State Machine  
6.11.3 External Request State Machine  
# Chapter 7  Address Collision Resolution Tables  
7.1 Introduction  
7.2 Resolving an Outstanding READ_HOME Transaction   
7.3 Resolving an Outstanding IREAD_HOME Transaction  
7.4 Resolving an Outstanding READ_OWNER Transaction   
7.5 Resolving an Outstanding READ_TO_OWN_HOME Transaction   
7.6 Resolving an Outstanding READ_TO_OWN_OWNER Transaction  
7.7 Resolving an Outstanding DKILL_HOME Transaction   
7.8 Resolving an Outstanding DKILL_SHARER Transaction   
7.9 Resolving an Outstanding IKILL_HOME Transaction  
7.10 Resolving an Outstanding IKILL_SHARER Transaction  
7.11 Resolving an Outstanding CASTOUT Transaction  
7.12 Resolving an Outstanding TLBIE or TLBSYNC Transaction   
7.13 Resolving an Outstanding FLUSH Transaction   
7.14 Resolving an Outstanding IO_READ_HOME Transaction   
7.15 Resolving an Outstanding IO_READ_OWNER Transaction   
# Part 6: LP-Serial Physical Layer  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Contents   
1.3 Terminology  
1.4 Conventions   
# Chapter 2  Packets  
2.1 Introduction  
2.2 Packet Field Definitions  
2.3 Packet Format   
2.4 Packet Protection   
2.4.1 Packet CRC Operation  
2.4.2 CRC-16 Code  
2.5 Maximum Packet Size   
# Chapter 3  Control Symbols  
3.1 Introduction  
3.2 Control Symbol Field Definitions  
3.3 Control Symbol Format   
3.4 Stype0 Control Symbols   
3.4.1 Packet-Accepted Control Symbol  
3.4.2 Packet-Retry Control Symbol  
3.4.3 Packet-Not-Accepted Control Symbol   
3.4.4 Status Control Symbol  
3.4.5 VC-Status Control Symbol  
3.4.6 Link-Response Control Symbol   
3.5 Stype1 Control Symbols   
3.5.1 Start-of-Packet Control Symbol  
3.5.2 Stomp Control Symbol   
3.5.3 End-of-Packet Control Symbol  
3.5.4 Restart-From-Retry Control Symbol   
3.5.5 Link-Request Control Symbol  
3.5.5.1 Reset-Device Command   
3.5.5.2 Input-Status Command   
3.5.6 Multicast-Event Control Symbol  
3.6 Control Symbol Protection   
3.6.1 CRC-5 Code  
3.6.2 CRC-5 Parallel Code Generation  
3.6.3 CRC-13 Code  
3.6.4 CRC-13 Parallel Code Generation  
# Chapter 4  PCS and PMA Layers  
4.1 Introduction  
4.2 PCS Layer Functions   
4.3 PMA Layer Functions  
4.4 Definitions   
4.5 8B/10B Transmission Code  
4.5.1 Character and Code-Group Notation  
4.5.2 Running Disparity  
4.5.3 Running Disparity Rules  
4.5.4 8B/10B Encoding  
4.5.5 Transmission Order  
4.5.6 8B/10B Decoding   
4.5.7 Special Characters and Columns   
4.5.7.1 Packet Delimiter Control Symbol (/PD/)  
4.5.7.2 Start of Control Symbol (/SC/)  
4.5.7.3 Idle (/I/)  
4.5.7.4 Sync (/K/)  
4.5.7.5 Skip (/R/)   
4.5.7.6 Align (/A/)   
4.5.7.7 Mark (/M/)   
4.5.7.8 Illegal   
4.5.8 Effect of Single Bit Code-Group Errors   
4.6 LP-Serial Link Widths  
4.7 Idle Sequence  
4.7.1 Clock Compensation Sequence   
4.7.2 Idle Sequence 1 (IDLE1)  
4.7.3 Idle Sequence 1 Generation   
4.7.4 Idle Sequence 2 (IDLE2)  
4.7.4.1 Idle Frame  
4.7.4.1.1 IDLE Sequence 2 Random Data Field   
4.7.4.1.2 IDLE Sequence 2 CS Field Marker  
4.7.4.1.3 IDLE2 Command and Status Field (CS field)  
4.7.4.1.4 IDLE2 CS Field Use  
4.7.5 Idle Sequence Selection  
4.8 Scrambling  
4.8.1 Scrambling Rules  
4.8.2 Descrambler Synchronization  
4.8.3 Descrambler Synchronization Verification   
4.9 1x Mode Transmission Rules   
4.9.1 1x Ports   
4.9.2 Nx Ports Operating in 1x Mode  
4.10 Nx Link Striping and Transmission Rules  
4.11 Retimers and Repeaters   
4.11.1 Retimers  
4.11.2 Repeaters  
4.12 Port Initialization   
4.12.1 1x Mode Initialization  
4.12.2 1x/Nx Mode Initialization  
4.12.3 Baud Rate Discovery   
4.12.4 State Machines  
4.12.4.1 State Machine Conventions, Functions and Variables   
4.12.4.1.1 State Machine Conventions  
4.12.4.1.2 State Machine Functions   
4.12.4.1.3 State Machine Variables  
4.12.4.2 Lane Synchronization State Machine   
4.12.4.3 Lane Alignment State Machine   
4.12.4.4 1x/2x Mode Detect State Machine   
4.12.4.5 1x Mode Initialization State Machine  
4.12.4.6 1x/Nx Mode Initialization State Machine for N = 4, 8, 16  
4.12.4.7 1x/2x Mode Initialization State Machine   
4.12.4.8 1x/Mx/Nx Mode Initialization State Machines   
4.12.4.8.1 1x/2x/Nx Initialization State Machine  
4.12.4.8.2 1x/Mx/Nx Initialization State Machine (N > M > 2)   
# Chapter 5  LP-Serial Protocol  
5.1 Introduction  
5.2 Packet Exchange Protocol   
5.3 Traffic types  
5.4 Virtual Channels   
5.4.1 Virtual channel 0 (VC0)   
5.4.2 Virtual Channels 1-8 (VC1-8)   
5.4.3 Virtual Channel Utilization  
5.5 Control Symbols   
5.5.1 Control Symbol Selection  
5.5.2 Control Symbol Delimiting   
5.5.3 Control Symbol Use   
5.5.3.1 Link Initialization   
5.5.3.2 Buffer Status Maintenance   
5.5.3.3 Embedded Control Symbols  
5.5.3.4 Multicast-Event Control Symbols   
5.6 Packets   
5.6.1 Packet Delimiting   
5.6.1.1 Packet Start   
5.6.1.2 Packet Termination  
5.6.2 Acknowledgment Identifier  
5.6.3 Packet Priority and Transaction Request Flows   
5.7 Link Maintenance Protocol  
5.8 Packet Transmission Protocol  
5.9 Flow Control  
5.9.1 Receiver-Controlled Flow Control   
5.9.1.1 Reliable Traffic VC Receivers  
5.9.1.2 Continuous Traffic VC Receivers   
5.9.1.3 Single VC Retry Protocol  
5.9.1.4 Input Retry-Stopped Recovery Process  
5.9.1.5 Output Retry-Stopped Recovery Process   
5.9.2 Transmitter-Controlled Flow Control  
5.9.2.1 Receive Buffer Management   
5.9.2.2 Effective Number of Free Receive Buffers   
5.9.2.3 Speculative Packet Transmission   
5.9.3 Flow Control Mode Negotiation  
5.10 Canceling Packets  
5.11 Transaction and Packet Delivery Ordering Rules  
5.12 Deadlock Avoidance  
5.13 Error Detection and Recovery   
5.13.1 Lost Packet Detection  
5.13.2 Link Behavior Under Error  
5.13.2.1 Recoverable Errors   
5.13.2.2 Idle Sequence Errors  
5.13.2.2.1 IDLE1 Sequence Errors  
5.13.2.2.2 IDLE2 Sequence Errors  
5.13.2.3 Control Symbol Errors  
5.13.2.3.1 Link Protocol Violations   
5.13.2.3.2 Corrupted Control symbols   
5.13.2.4 Packet Errors  
5.13.2.5 Link Timeout   
5.13.2.6 Input Error-Stopped Recovery Process   
5.13.2.7 Output Error-Stopped Recovery Process  
5.14 Power Management   
# Chapter 6   LP-Serial Registers  
6.1 Introduction  
6.2 Register Map  
6.3 Reserved Register, Bit and Bit Field Value Behavior   
6.4 Capability Registers (CARs)   
6.4.1 Processing Element Features CAR  
(Configuration Space Offset 0x10) 170  
6.5 LP-Serial Extended Feature Blocks  
6.5.1 Generic End Point Devices  
6.5.2 Generic End Point Devices, software assisted error recovery option  
6.5.3 Generic End Point Free Devices  
6.5.4 Generic End Point Free Devices, software assisted error recovery option  
6.6 LP-Serial Command and Status Registers (CSRs)   
6.6.1  LP-Serial Register Block Header (Block Offset 0x0)   
6.6.2 Port Link Timeout Control CSR (Block Offset 0x20)  
6.6.3 Port Response Timeout Control CSR (Block Offset 0x24)  
6.6.4 Port General Control CSR (Block Offset 0x3C)   
6.6.5 Port n Link Maintenance Request CSRs (Block Offsets 0x40, 60,   
6.6.6 Port n Link Maintenance Response CSRs (Block Offsets 0x44, 64,   
6.6.7 Port n Local ackID CSRs (Block Offsets 0x48, 68,   
6.6.8 Port n Error and Status CSRs (Block Offset 0x58, 78,   
6.6.9 Port n Control CSRs (Block Offsets 0x5C, 7C,   
6.6.10 Port n Control 2 CSRs (Block Offset 0x54, 74,   
6.7 LP-Serial Lane Extended Features Block  
6.7.1 Register Map  
6.7.2 LP-Serial Lane Command and Status Registers (CSRs)   
6.7.2.1 LP-Serial Register Block Header (Block Offset 0x0)   
6.7.2.2 Lane n Status 0 CSRs (Block Offsets 0x10, 30,   
6.7.2.3 Lane n Status 1 CSRs (Block Offsets 0x14, 34,   
6.7.2.4 Implementation Specific CSRs  
6.7.2.4.1 Lane n Status 2 CSR (Block Offsets 0x18, 38,   
6.7.2.4.2 Lane n Status 3 CSR (Block Offsets 0x1C, 3C,   
6.7.2.4.3 Lane n Status 4 CSR (Block Offsets 0x20, 40,   
6.7.2.4.4 Lane n Status 5 CSR (Block Offsets 0x24, 44,   
6.7.2.4.5 Lane n Status 6 CSR (Block Offsets 0x28, 48,   
6.7.2.4.6 Lane n Status 7 CSR (Block Offsets 0x2C, 4C,   
6.8 Virtual Channel Extended Features Block  
6.8.1 Register Map  
6.8.2 Virtual Channel Control Block Registers  
6.8.2.1 VC Register Block Header (Block Offset 0x0)  
6.8.2.2 Port n VC Control and Status Registers  
(Block Offset ((port number) + 1) * 0x20))   
6.8.2.3 Port n VC0 BW Allocation Registers  
(Block Offset (((port number) + 1) * 0x20) + 0x04))  
6.8.2.4 Port n VCx BW Allocation Registers  
(Block Offset ((((port number) + 1) * 0x20) +   
(offset based on VC #, see Table 6-23)))  
# Chapter 7  Signal Descriptions  
7.1 Introduction  
7.2 Signal Definitions   
7.3 Serial RapidIO Interface Diagrams  
# Chapter 8  Common Electrical Specifications  
8.1 Introduction  
8.2 References  
8.3 Abbreviations  
8.4 Definitions   
8.4.1 Definition of Amplitude and Swing  
8.4.2 Transmitter (Near-End) Template   
8.4.3 Receiver (Far-End) Template   
8.4.3.1 Level I Receiver Template  
8.4.3.2 Level II Receiver Template   
8.4.4 Definition of Skew and Relative Wander  
8.4.5 Total Wander Mask   
8.4.6 Relative Wander Mask  
8.4.7 Random Jitter Mask  
8.4.8 Defined Test Patterns  
8.4.9 Reference Model  
8.5 Common Electrical Specification   
8.5.1 Introduction  
8.5.2 Data Patterns  
8.5.3 Signal Levels  
8.5.4 Bit Error Ratio   
8.5.4.1 Level I Bit Error Ratio  
8.5.4.2 Level II Bit Error Ratio  
8.5.5 Ground Differences  
8.5.6 Cross Talk  
8.5.7 Transmitter Test Load  
8.5.8 Transmitter Lane-to-Lane Skew  
8.5.9 Receiver Input Lane-to-Lane Skew   
8.5.10 Transmitter Short Circuit Current  
8.5.11 Differential Resistance and Return Loss, Transmitter and Receiver  
8.5.12 Baud Rate Tolerance  
8.5.13 Termination and DC Blocking  
8.6 Pulse Response Channel Modelling   
8.6.1 Generating a Pulse Response  
8.6.2 Basic Pulse Response Definitions  
8.6.3 Transmitter Pulse Definition  
8.6.4 Receiver Pulse Response   
8.6.5 Crosstalk Pulse Response   
8.6.6 Decision Feedback Equalizer  
8.6.7 Time Continuous Transverse Filter   
8.6.7.1 Time Continuous Zero-Pole Equalizer Adaption   
8.6.8 Time Continuous Zero/Pole  
8.6.9 Degrees of Freedom  
8.6.9.1 Receiver Sample Point  
8.6.9.2 Transmit Emphasis   
8.7 Jitter Modelling  
8.7.1 High Frequency Jitter vs. Wander   
8.7.2 Total Wander vs. Relative Wander  
8.7.3 Correlated vs. Uncorrelated Jitter  
8.7.4 Jitter Distributions   
8.7.4.1 Unbounded and Bounded Gaussian Distribution   
8.7.4.2 Bounded Gaussian Distribution  
8.7.4.3 High Probability Jitter  
8.7.4.4 Total Jitter  
8.7.4.5 Probability Distribution Function vs. Cumulative Distribution Function   
8.7.4.6 BathTub Curves  
8.7.4.7 Specification of GJ and HPJ  
8.7.4.8 Example of Bounded Gaussian  
8.7.5 Statistical Eye Methodology  
8.7.5.1 Derivation of Cursors and Calculation of PDF  
8.7.5.2 Inclusion of Sampling Jitter  
8.7.5.3 Generation of Statistical Eye   
# Chapter 9  1.25Gbaud, 2.5Gbaud, and 3.125Gbaud LP-Serial Links  
9.1 Level I Application Goals  
9.2 Equalization   
9.3 Explanatory Note on Level I Transmitter and Receiver Specifications   
9.4 Level I Electrical Specification  
9.4.1 Level I Short Run Transmitter Characteristics   
9.4.1.1 Level I SR Transmitter Test Load   
9.4.1.2 Level I SR Transmitter Baud Rate  
9.4.1.3 Level I SR Transmitter Amplitude and Swing   
9.4.1.4 Level I SR Transmitter Rise and Fall Times   
9.4.1.5 Level I SR Transmitter Differential Pair Skew   
9.4.1.6 Level I SR Transmitter Output Resistance and Return Loss  
9.4.1.7 Level I SR Transmitter Lane-to-Lane Skew  
9.4.1.8 Level I SR Transmitter Short Circuit Current   
9.4.1.9 Level I SR Transmitter Template and Jitter   
9.4.2 Level I Long Run Transmitter Characteristics   
9.4.2.1 Level I LR Transmitter Test Load  
9.4.2.2 Level I LR Transmitter Baud Rate   
9.4.2.3 Level I LR Transmitter Amplitude and Swing  
9.4.2.4 Level I LR Transmitter Rise and Fall Times  
9.4.2.5 Level I LR Transmitter Differential Pair Skew  
9.4.2.6 Level I LR Transmitter Output Resistance and Return Loss  
9.4.2.7 Level I LR Transmitter Lane-to-Lane Skew   
9.4.2.8 Level I LR Transmitter Short Circuit Current  
9.4.2.9 Level I LR Transmitter Template and Jitter   
9.4.3 Level I Receiver Specifications  
9.4.3.1 Level I Receiver Input Baud Rate   
9.4.3.2 Level I Receiver Reference Input Signals   
9.4.3.3 Level I Receiver Input Signal Amplitude  
9.4.3.4 Level I Receiver Absolute Input Voltage   
9.4.3.5 Level I Receiver Input Common Mode Impedance   
9.4.3.6 Level I Receiver Input Lane-to-Lane Skew  
9.4.3.7 Level I Receiver Input Resistance and Return Loss  
9.4.3.8 Level I Receiver Input Jitter Tolerance   
9.5 Level I Measurement and Test Requirements   
9.5.1 Level I Transmitter Measurements  
9.5.1.1 Level I Eye Template Measurements   
9.5.1.2 Level I Jitter Test Measurements  
9.5.1.3 Level I Transmit Jitter Load   
9.5.2 Level I Receiver Jitter Tolerance  
# Chapter 10  5Gbaud and 6.25Gbaud LP-Serial Links  
10.1 Level II Application Goals   
10.1.1 Common to Level II Short run, Medium run and Long run   
10.1.2 Application Goals for Level II Short Run   
10.1.3 Application Goals for Level II Medium Run  
10.1.4 Application Goals for Long Run   
10.1.5 Explanatory Note on Transmitter and Receiver Specifications  
10.2 Equalization   
10.3 Link Compliance Methodology  
10.3.1 Overview  
10.3.2 Reference Models   
10.3.3 Channel Compliance  
10.3.4 Transmitter Compliance   
10.3.5 Receiver Compliance  
10.4 Level II Short Run Interface - General Requirements  
10.4.1 Jitter and Inter-operability Methodology  
10.4.1.1 Level II SR Defined Test Patterns  
10.4.1.2 Level II SR Channel Compliance  
10.4.1.3 Level II SR Transmitter Inter-operability  
10.4.1.4 Level II SR Receiver Inter-operability   
10.4.2 Level II SR Electrical Characteristics  
10.4.2.1 Level II SR Transmitter Characteristics   
10.4.2.1.1 Level II SR Transmitter Test Load  
10.4.2.1.2 Level II SR Transmitter Baud Rate   
10.4.2.1.3 Level II SR Transmitter Amplitude and Swing  
10.4.2.1.4 Level II SR Transmitter Rise and Fall Times  
10.4.2.1.5 Level II SR Transmitter Differential Pair Skew  
10.4.2.1.6 Level II SR Transmitter Output Resistance and Return Loss   
10.4.2.1.7 Level II SR Transmitter Lane-to-Lane Skew   
10.4.2.1.8 Level II SR Transmitter Template and Jitter  
10.4.2.2 Level II SR Receiver Characteristics  
10.4.2.2.1 Level II SR Receiver Input Baud Rate   
10.4.2.2.2 Level II SR Receiver Reference Input Signals  
10.4.2.2.3 Level II SR Receiver Input Signal Amplitude  
10.4.2.2.4 Level II SR Receiver Absolute Input Voltage  
10.4.2.2.5 Level II SR Receiver Input Common Mode Impedance   
10.4.2.2.6 Level II SR Receiver Input Lane-to-Lane Skew   
10.4.2.2.7 Level II SR Receiver Input Resistance and Return Loss  
10.4.2.2.8 Level II SR Receiver Input Jitter Tolerance  
10.4.2.3 Level II SR Link and Jitter Budgets   
10.4.3 Level II SR StatEye.org Template  
10.5 Level II Long Run Interface General Requirements   
10.5.1 Long Run Jitter and Inter-operability Methodology  
10.5.1.1 Level II LR Channel Compliance  
10.5.1.2 Level II LR Transmitter Inter-operability  
10.5.1.3 Level II LR Receiver Inter-operability  
10.5.2 Level II LR Interface Electrical Characteristics   
10.5.2.1 Level II LR Transmitter Characteristics  
10.5.2.1.1 Level II LR Transmitter Test Load  
10.5.2.1.2 Level II LR Transmitter Baud Rate  
10.5.2.1.3 Level II LR Transmitter Amplitude and Swing  
10.5.2.1.4 Level II LR Transmitter Rise and Fall Times  
10.5.2.1.5 Level II LR Transmitter Differential Pair Skew  
10.5.2.1.6 Level II LR Transmitter Output Resistance and Return Loss   
10.5.2.1.7 Level II LR Transmitter Lane-to-Lane Skew  
10.5.2.1.8 Level II LR Transmitter Short Circuit Current  
10.5.2.1.9 Level II LR Transmitter Template and Jitter  
10.5.2.2 Level II LR Receiver Characteristics   
10.5.2.2.1 Level II LR Receiver Input Baud Rate  
10.5.2.2.2 Level II LR Receiver Reference Input Signals  
10.5.2.2.3 Level II LR Receiver Input Signal Amplitude   
10.5.2.2.4 Level II LR Receiver Absolute Input Voltage  
10.5.2.2.5 Level II LR Receiver Input Common Mode Impedance  
10.5.2.2.6 Level II LR Receiver Input Lane-to-Lane Skew  
10.5.2.2.7 Level II LR Receiver Input Resistance and Return Loss   
10.5.2.2.8 Level II LR Receiver Jitter Tolerance   
10.5.3 Level II LR Link and Jitter Budgets  
10.5.4 Level II LR StatEye.org Template  
10.6 Level II Medium Run Interface General Requirements   
10.6.1 Medium Run Jitter and Inter-operability Methodology  
10.6.1.1 Level II Medium Run Channel Compliance  
10.6.1.2 Level II MR Transmitter Inter-operability   
10.6.1.3 Medium Receiver Inter-operability   
10.6.2 Level II MR Interface Electrical Characteristics  
10.6.2.1 Level II MR Transmitter Characteristics  
10.6.2.1.1 Level II MR Transmitter Test Load   
10.6.2.1.2 Level II MR Transmitter Baud Rate  
10.6.2.1.3 Level II MR Transmitter Amplitude and Swing   
10.6.2.1.4 Level II MR Transmitter Rise and Fall Times   
10.6.2.1.5 Level II MR Transmitter Differential Pair Skew  
10.6.2.1.6 Level II MR Transmitter Output Resistance and Return Loss   
10.6.2.1.7 Level II MR Transmitter Lane-to-Lane Skew  
10.6.2.1.8 Level II MR Transmitter Short Circuit Current  
10.6.2.1.9 Level II MR Transmitter Template and Jitter  
10.6.2.2 Level II MR Receiver Characteristics   
10.6.2.2.1 Level II MR Receiver Input Baud Rate  
10.6.2.2.2 Level II MR Receiver Reference Input Signals  
10.6.2.2.3 Level II MR Receiver Input Signal Amplitude   
10.6.2.2.4 Level II MR Receiver Absolute Input Voltage   
10.6.2.2.5 Level II MR Receiver Input Common Mode Impedance  
10.6.2.2.6 Level II MR Receiver Input Lane-to-Lane Skew  
10.6.2.2.7 Level II MR Receiver Input Resistance and Return Loss   
10.6.2.2.8 Level II MR Receiver Jitter Tolerance  
10.6.3 Level II MR Link and Jitter Budgets  
10.6.4 Level II MR StatEye.org Template  
10.7 Level II Measurement and Test Requirements  
10.7.1 High Frequency Transmit Jitter Measurement   
10.7.1.1 BERT Implementation  
10.7.1.2 Spectrum Analyzer and Oscilloscope Methodology   
10.7.1.2.1 Band Limited Unbounded Gaussian Noise   
10.7.1.2.2 Band Limited 60 Second Total Jitter Measurements  
10.7.1.2.3 Uncorrelated High Probability Jitter  
10.7.1.2.4 Total High Probability Jitter  
10.7.2 Total Transmit Wander Measurement  
10.7.3 Relative Transmit Wander Measurement   
10.7.4 Jitter Tolerance   
10.7.4.1 Jitter Tolerance with Relative Wander Lab Setup  
10.7.4.1.1 General  
10.7.4.1.2 Synchronization  
10.7.4.1.3 Jitter   
10.7.4.1.4 Amplitude   
10.7.4.2 Jitter Tolerance with no Relative Wander Lab Setup  
10.7.4.3 Jitter Tolerance with Defined ISI and no Relative Wander  
10.7.4.4 Jitter Transfer  
10.7.4.5 Network Analysis Measurement  
10.7.4.6 Eye Mask Measurement Setup   
# Annex A  Transmission Line Theory and Channel Information (Informative)  
A.1 Transmission Lines Theory   
A.2 Impedance Matching  
A.3 Impedance Definition Details   
A.4 Density considerations  
A.5 Common-Mode Impedance and Return Loss   
A.6 Crosstalk Considerations   
A.7 Equation Based Channel Loss by Curve Fit   
# Annex B  BER Adjustment Methodology (Informative)  
B.1 Extrapolation of Correlated Bounded Gaussian Jitter to low BERs  
B.1.1 Bathtub Measurements   
B.2 Confidence Level of Errors Measurement  
B.3 Eye Mask Adjustment for Sampling Oscilloscopes   
B.3.1 Theory  
B.3.2 Usage   
# Annex C  Interface Management (Informative)  
C.1 Introduction  
C.2 Packet Retry Mechanism   
C.2.1 Input port retry recovery state machine   
C.2.2 Output port retry recovery state machine   
C.3 Error Recovery  
C.3.1 Input port error recovery state machine  
C.3.2 Output port error recovery state machine   
C.3.3 Changes in Error Recovery Behavior for CT   
# Annex D  Critical Resource Performance Limits (Informative)  
# Annex E  Manufacturability and Testability (Informative)  
# Annex F  Multiple Port Configuration Example (Informative)  
F.1 Introduction  
F.2 System with Different Port Width Capabilities   
# Part 7: System and Device Inter-operability  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
# Chapter 2  System Exploration and Initialization  
2.1 Introduction  
2.2 Boot code access  
2.3 Exploration and initialization  
2.3.1 Exploration and initialization rules  
2.3.2 Exploration and initialization algorithm  
2.3.3 Exploration and initialization example  
# Chapter 3  RapidIO Device Class Requirements  
3.1 Introduction  
3.2 Class Partitioning  
3.2.1 Generic: All devices  
3.2.1.1 General requirements  
3.2.1.2 Operation support as target  
3.2.1.3 Operation support as source  
3.2.2 Class 1: Simple target device  
3.2.2.1 General requirements  
3.2.2.2 Operation support as target  
3.2.2.3 Operation support as source  
3.2.3 Class 2: Simple mastering device  
3.2.3.1 General requirements  
3.2.3.2 Operation support as target  
3.2.3.3 Operation support as source  
3.2.4 Class 3: Complex mastering device  
3.2.4.1 General requirements  
3.2.4.2 Operation support as target  
3.2.4.3 Operation support as source  
# Chapter 4  PCI Considerations  
4.1 Introduction  
4.2 Address Map Considerations  
4.3 Transaction Flow   
4.3.1 PCI 2.2 Transaction Flow  
4.3.2 PCI-X Transaction Flow  
4.4 RapidIO to PCI Transaction Mapping  
4.5 Operation Ordering and Transaction Delivery   
4.5.1 Operation Ordering  
4.5.2 Transaction Delivery Ordering  
4.5.3 PCI-X Relaxed Ordering Considerations   
4.6 Interactions with Globally Shared Memory  
4.6.1 I/O Read Operation Details  
4.6.1.1 Internal Request State Machine  
4.6.1.2 Response State Machine  
4.6.2 Data Cache Flush Operation Details  
4.6.2.1 Internal Request State Machine  
4.6.2.2 Response State Machine  
4.7 Byte Lane and Byte Enable Usage   
4.8 Error Management   
# Chapter 5  Globally Shared Memory Devices  
5.1 Introduction  
5.2 Processing Element Behavior   
5.2.1 Processor-Memory Processing Element  
5.2.1.1 I/O Read Operations   
5.2.1.1.1 Response State Machine  
5.2.1.1.2 External Request State Machine  
5.2.2 Memory-only Processing Element  
5.2.2.1 Read Operations  
5.2.2.1.1 Response State Machine  
5.2.2.1.2 External Request State Machine  
5.2.2.2 Instruction Read Operations   
5.2.2.2.1 Response State Machine  
5.2.2.2.2 External Request State Machine  
5.2.2.3 Read for Ownership Operations   
5.2.2.3.1 Response State Machine  
5.2.2.3.2 External Request State Machine  
5.2.2.4 Data Cache and Instruction Cache Invalidate Operations   
5.2.2.4.1 Response State Machine  
5.2.2.4.2 External Request State Machine  
5.2.2.5 Castout Operations  
5.2.2.5.1 External Request State Machine  
5.2.2.6 Data Cache Flush Operations   
5.2.2.6.1 Response State Machine  
5.2.2.6.2 External Request State Machine  
5.2.2.7 I/O Read Operations   
5.2.2.7.1 Response State Machine  
5.2.2.7.2 External Request State Machine  
5.2.3 Processor-only Processing Element  
5.2.3.1 Read Operations  
5.2.3.1.1 Internal Request State Machine  
5.2.3.1.2 Response State Machine  
5.2.3.1.3 External Request State Machine  
5.2.3.2 Instruction Read Operations   
5.2.3.2.1 Internal Request State Machine  
5.2.3.2.2 Response State Machine  
5.2.3.2.3 External Request State Machine  
5.2.3.3 Read for Ownership Operations   
5.2.3.3.1 Internal Request State Machine  
5.2.3.3.2 Response State Machine  
5.2.3.3.3 External Request State Machine  
5.2.3.4 Data Cache and Instruction Cache Invalidate Operations   
5.2.3.4.1 Internal Request State Machine  
5.2.3.4.2 Response State Machine  
5.2.3.4.3 External Request State Machine  
5.2.3.5 Castout Operations  
5.2.3.5.1 Internal Request State Machine  
5.2.3.5.2 Response State Machine  
5.2.3.6 TLB Invalidate Entry, TLB Invalidate Entry Synchronize Operations  
5.2.3.6.1 Internal Request State Machine  
5.2.3.6.2 Response State Machine  
5.2.3.6.3 External Request State Machine  
5.2.3.7 Data Cache Flush Operations   
5.2.3.7.1 Internal Request State Machine  
5.2.3.7.2 Response State Machine  
5.2.3.7.3 External Request State Machine  
5.2.3.8 I/O Read Operations   
5.2.3.8.1 External Request State Machine  
5.2.4 I/O Processing Element   
5.2.4.1 I/O Read Operations   
5.2.4.1.1 Internal Request State Machine  
5.2.4.1.2 Response State Machine  
5.2.4.2 Data Cache Flush Operations   
5.2.4.2.1 Internal Request State Machine  
5.2.4.2.2 Response State Machine  
5.2.5 Switch Processing Element  
5.3 Transaction to Priority Mappings   
# Part 8: Error Management Extensions  
# Chapter 1  Error Management Extensions  
1.1 Introduction  
1.2 Physical Layer Extensions  
1.2.1 Port n Error Detect, Enable and Capture CSRs   
1.2.2 Error Reporting Thresholds   
1.2.3 Error Rate Control and Status  
1.2.4 Port Behavior When Error Rate Failed Threshold is Reached  
1.2.5 Packet Timeout Mechanism in a Switch Device   
1.3 Logical and Transport Layer Extensions  
1.3.1 Logical/Transport Error Detect, Enable and Capture CSRs  
1.3.2 Message Passing Error Detection   
1.4 System Software Notification of Error   
1.5 Mechanisms for Software Debug   
# Chapter 2  Error Management Registers  
2.1 Introduction  
2.2 Additions to Existing Registers   
2.3 New Error Management Registers  
2.3.1 Register Map  
2.3.2 Command and Status Registers (CSRs)   
2.3.2.1 Error Management Extensions Block Header (Block Offset 0x0)   
2.3.2.2 Logical/Transport Layer Error Detect CSR (Block Offset 0x08)   
2.3.2.3 Logical/Transport Layer Error Enable CSR (Block Offset 0x0C)   
2.3.2.4 Logical/Transport Layer High Address Capture CSR (Block Offset 0x10). 23  
2.3.2.5 Logical/Transport Layer Address Capture CSR (Block Offset 0x14)  
2.3.2.6 Logical/Transport Layer Device ID Capture CSR (Block Offset 0x18)   
2.3.2.7 Logical/Transport Layer Control Capture CSR (Block Offset 0x1C)  
2.3.2.8 Port-write Target deviceID CSR (Block Offset 0x28)   
2.3.2.9 Packet Time-to-live CSR (Block Offset 0x2C)  
2.3.2.10 Port n Error Detect CSR (Block Offset 0x40, 80,  
2.3.2.11 Port n Error Rate Enable CSR (Block Offset 0x44, 84,  
2.3.2.12 Port n Attributes Capture CSR (Block Offset 0x48, 88,  
2.3.2.13 Port n Packet/Control Symbol Capture 0 CSR  
(Block Offset 0x4C, 8C,  
2.3.2.14 Port n Packet Capture 1 CSR (Block Offset 0x50, 90,  
2.3.2.15 Port n Packet Capture 2 CSR (Block Offset 0x54, 94,  
2.3.2.16 Port n Packet Capture 3 CSR (Block Offset 0x58, 98,  
2.3.2.17 Port n Error Rate CSR (Block Offset 0x68, A8,  
2.3.2.18 Port n Error Rate Threshold CSR (Block Offset 0x6C, AC,  
# Annex A  Error Management Discussion (Informative)  
A.1 Introduction  
A.2 Limitations of Error Management Discussion  
A.3 Hot-insertion/extraction Discussion   
A.4 Port-write Discussion  
A.5 Physical Layer Fatal Error Recovery Discussion   
# Part 9: Flow Control Logical Layer Extensions  
# Chapter 1  Flow Control Overview  
1.1 Congestion Management   
1.1.1 Introduction  
1.1.2 Requirements   
1.1.3 Problem Illustration   
1.2 Flow Arbitration   
1.2.1 Fixed / Static Resource Allocation   
1.2.2 Dynamic Resource Allocation Protocol   
# Chapter 2  Logical Layer Flow Control Operation  
2.1 Fabric Link Congestion   
2.2 Flow Arbitration   
2.2.1 Arbitration Protocol   
2.2.2 Number Of Outstanding Requests   
2.3 Flow Control Operation  
2.4 Physical Layer Requirements   
2.4.1 Fabric Topology  
2.4.2 Flow Control Transaction Transmission  
2.4.2.1 Orphaned XOFF Mechanism  
2.4.2.2 Controlled Flow List  
2.4.2.3 XOFF/XON Counters  
2.4.3 Priority to Transaction Request Flow Mapping  
2.4.4 Flow Control Transaction Ordering Rules  
2.4.5 End Point Congestion Management Rules   
2.4.6 Switch Congestion Management Rules   
2.4.7 Endpoint Rules for the Arbitration Protocol  
2.4.8 Abnormal De-allocation of Resources  
# Chapter 3  Packet Format Descriptions  
3.1 Introduction  
3.2 Logical Layer Packet Format  
3.3 Flow Arbitration Message Fields (FAM)   
3.4 Transport and Physical Layer Packet Format  
# Chapter 4  Logical Layer Flow Control Extensions Register Bits  
4.1 Introduction  
4.2 Processing Elements Features CAR (Offset 0x10 Word 0)  
4.3 Port n Control CSR (Block Offsets 0x5C, 7C,   
# Annex A   Flow Control Examples (Informative)  
A.1 Congestion Detection and Remediation   
A.2 Orphaned XOFF Mechanism Description   
A.3 Discussion on Flow Arbitration  
# Part 10: Data Streaming Logical   
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Features of the Data Streaming Specification  
1.3.1 Functional Features  
1.3.2 Physical Features   
1.3.3 Performance Features   
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
1.7 Useful References  
# Chapter 2  Data Streaming Systems  
2.1 Introduction  
2.2 System Example   
2.3 Traffic Streams   
2.4 Operation Ordering  
2.5 Class of Service and Virtual Queues   
2.6 End-to-end Traffic Management   
2.7 Deadlock Considerations   
# Chapter 3  Operation Descriptions  
3.1 Introduction  
3.2 Data Streaming Protocol  
3.2.1 Data Streaming Operation   
3.2.2 Virtual Streams   
3.2.3 PDU Sequences Within Streams  
3.2.4 Segments within a PDU  
3.2.5 Rules for Segmentation and Reassembly  
3.3 Class of Service and Traffic Streams  
3.4 Traffic Management   
3.4.1 Traffic Management Operand  
3.4.2 On/Off Traffic Management  
3.4.3 Rate Base Traffic Management   
3.4.4 Credit Based Traffic Management  
3.4.5 Rules for Traffic Management  
# Chapter 4  Packet Format Descriptions  
4.1 Introduction  
4.2 Type 9 Packet Format (Data-Streaming Class)   
4.3 Type 9 Extended Packet Format  
4.3.1 TM Operand  
4.3.2 Basic Traffic Management  
4.3.3 Rate Based Traffic Management   
4.3.4 Credit Based Traffic Management  
# Chapter 5  Data Streaming Registers  
5.1 Introduction  
5.2 Register Summary  
5.3 Reserved Register, Bit and Bit Field Value Behavior   
5.4 Additions to Existing Registers   
5.5 Capability Registers (CARs)   
5.5.1 Source Operations CAR (Configuration Space Offset 0x18)  
5.5.2 Destination Operations CAR (Configuration Space Offset 0x1C)  
5.5.3 Data Streaming Information CAR (Configuration Space Offset 0x3C)  
5.6 Command and Status Registers (CSRs)  
5.6.1 Data Streaming Logical Layer Control CSR  
(Configuration Space Offset 0x48)  
# Annex A   VSID Usage Examples  
A.1 Introduction  
A.2 Background  
A.3 Packet Classification  
A.3.1 Sub-port Addressing at the Destination  
A.3.1.1 DSLAM application  
A.3.1.2 VOIP application   
A.3.2 Virtual Output Queueing - Fabric On-ramp   
A.4 System Requirements   
A.4.1 UTOPIA to RapidIO ATM bridge  
A.4.2 Network processor   
A.4.3 CSIX to RapidIO interface   
A.4.4 10Gb Metropolitan Area Network interface  
# Part 11: Multicast Extensions   
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Requirements   
# Chapter 2  Multicast Extensions Behavior  
2.1 Introduction  
2.2 Packet Replication   
2.3 Multicast Operation   
2.4 Multicast Transaction Ordering Requirements  
# Chapter 3  Multicast Extensions Registers  
3.1 Introduction  
3.2 Processing Elements Features CAR (Configuration Space Offset 0x10)  
3.3 Switch Multicast Support CAR (Configuration Space Offset 0x30)  
3.4 Switch Multicast Information CAR (Configuration Space Offset 0x38)   
3.5 Multicast Mask Port CSR (Configuration Space Offset 0x80)  
3.6 Multicast Associate Select CSR (Configuration Space Offset 0x84)  
3.7 Multicast Associate Operation CSR (Configuration Space Offset 0x88)  
# Chapter 4  Configuration Examples  
4.1 Introduction  
4.2 Configuring Multicast Masks   
4.2.1 Clearing Multicast Masks  
4.2.2 Assigning Ports to Multicast Masks   
4.2.3 Removing a Port from a Multicast Mask  
4.2.4 Querying a Multicast Mask  
4.3 Simple Association   
4.3.1 Restrictions on Block Size  
4.3.2 Restrictions on Block Associate   
4.3.3 Restrictions on Associations  
4.4 Configuring Associations   
4.4.1 Basic Association  
4.4.2 Using Per-Ingress Port Association  
4.4.3 Using Block Association   
4.4.4 Using Per-Ingress Port and Block Association  
4.4.5 Removing a Destination ID to Multicast Mask Association   
4.4.6 Querying an Association  
# Annex A   End Point Considerations (Informative)  
A.1 Introduction  
A.2 Multicast Destination ID  
A.3 End Point Multicast Channels  
# Annex B   Multicast Applications (Informative)  
B.1 Introduction  
B.2 Example 1 - Static Multicast Masks   
B.3 Example 2 - Linking Multicast Masks to Destination IDs   
# Part 12: Virtual Output Queueing Extensions  
# Chapter 1  Introduction  
1.1 Problem Illustration   
1.2 Terminology  
1.3 Conventions   
# Chapter 2  Overview  
2.1 Congestion Message   
2.2 Traffic Staging   
2.3 Adding Device Independence  
2.4 Relationship With Virtual Channels  
2.5 Additional Queueing Considerations  
# Chapter 3  Control Symbol Format  
3.1 Stype2 Control Symbol  
3.2 VC_Status Symbol Linking  
# Chapter 4  Rules  
4.1 Implementation Rules  
4.2 Rules for Generating Backpressure Control Symbols   
4.3 Rules for Interpreting Backpressure Control Symbols  
# Chapter 5  Register Definitions  
5.1 VoQ Backpressure Extended Features Block  
5.1.1 Register Map  
5.1.2 VoQ Backpressure Control Block Registers   
5.1.2.1 LP-Serial VC Register Block Header (Block Offset 0x0)  
5.1.2.2 Port n VoQ Control Status Register  
(Block Offset - Variable, see Section 5.1.1)  
# Annex 1: Software/System Bring Up   
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Scope  
1.4 System Enumeration API  
1.5 Terminology  
1.6 Software Conventions  
# Chapter 2  Requirements for System Bring Up  
2.1 Introduction  
2.2 Boot Requirements   
2.3 Enumeration Completion  
2.4 Enumeration Time-Out  
2.5 Function Return Codes   
# Chapter 3  Hardware Abstraction Layer  
3.1 Introduction  
3.2 Device Addressing  
3.3 HAL Functions   
3.3.1 Types and Definitions  
3.3.2 rioGetNumLocalPorts  
3.3.3 rioConfigurationRead   
3.3.4 rioConfigurationWrite   
# Chapter 4  Standard Bring Up Functions  
4.1 Introduction  
4.2 Data Structures  
4.3 Bring Up Functions  
4.3.1 rioInitLib  
4.3.2 rioGetFeatures  
4.3.3 rioGetSwitchPortInfo  
4.3.4 rioGetExtFeaturesPtr   
4.3.5 rioGetNextExtFeaturesPtr  
4.3.6 rioGetSourceOps  
4.3.7 rioGetDestOps   
4.3.8 rioGetAddressMode  
4.3.9 rioGetBaseDeviceId  
4.3.10 rioSetBaseDeviceId   
4.3.11 rioAcquireDeviceLock  
4.3.12 rioReleaseDeviceLock  
4.3.13 rioGetComponentTag   
4.3.14 rioSetComponentTag  
4.3.15 rioGetPortErrStatus  
# Chapter 5  Routing-Table Manipulation Functions  
5.1 Introduction  
5.2 Routing Table Functions  
5.2.1 rioRouteAddEntry  
5.2.2 rioRouteGetEntry  
# Chapter 6  Device Access Routine Interface  
6.1 Introduction  
6.2 DAR Packaging   
6.3 Execution Environment   
6.4 Type Definitions   
6.5 DAR Functions   
6.5.1 rioDar_nameGetFunctionTable  
6.5.2 rioDarInitialize  
6.5.3 rioDarTerminate  
6.5.4 rioDarTestMatch  
6.5.5 rioDarRegister  
6.5.6 rioDarGetMemorySize  
6.5.7 rioDarGetSwitchInfo   
6.5.8 rioDarSetPortRoute  
6.5.9 rioDarGetPortRoute  
# Annex A   System Bring Up Guidelines (Informative)  
A.1 Introduction  
A.2 Overview of the System Bring Up Process   
A.3 System Enumeration Algorithm   
A.3.1 Data Structures, Constants, and Global Variables  
A.3.2 Pseudocode   
A.4 System Bring Up Example   
# Annex 2: Session Management Protocol  
# Chapter 1  Overview  
1.1 Introduction  
1.2 Overview  
1.3 Features of the Session Management Protocol  
1.4 Contents   
1.5 Terminology  
1.6 Conventions   
1.7 Useful References  
# Chapter 2  Managing Data Streams  
2.1 Introduction  
2.2 System Example   
2.3 Establishing Data Streams   
2.4 Data Streaming System Configurations  
# Chapter 3  Session Management Operation  
3.1 Introduction  
3.2 Initialization of Session Management Advertisement CSRs  
3.3 Contacting a Participating End point  
3.4 Establishing Conduits   
3.4.1 Master/Slave Configuration Conduit Establishment   
3.4.2 Peers Configuration Conduit Establishment  
3.4.3 Conduit Establishment Algorithm   
3.5 Management Messages  
3.5.1 Session Management Message Types  
3.5.1.1 REQUEST   
3.5.1.2 ADVERTISE   
3.5.1.3 OPEN  
3.5.1.4 ACCEPT  
3.5.1.5 REFUSE   
3.5.1.6 FLOW-CONTROL  
3.5.1.7 DATA   
3.5.1.8 CLOSE  
3.5.1.9 STATUS   
3.5.2 Message Header Fields   
3.5.2.1 Command Header Field: <CMD><VER>  
3.5.2.2 SourceID and DestID  
3.5.2.3 Protocol Identifier: <ProtoID>   
3.5.2.4 Class of Service: <COS>  
3.5.2.5 Stream Identifier: <StreamID>  
3.5.3 Session Management Protocol Attributes  
3.5.3.1 VENDOR Attribute   
3.5.3.2 DATA_OFFSET_VENDOR Attribute  
3.5.3.3 DATA_OFFSET Attribute   
3.5.3.4 REQUEST_RETRY_PERIOD Attribute   
3.5.3.5 REQUEST_TIMEOUT_PERIOD Attribute   
3.5.3.6 FLOW_CONTROL_XON_TIMEOUT_PERIOD Attribute  
3.5.3.7 OPEN_MESSAGE_NUMBER Attribute  
3.5.3.8 CONDUIT_STREAM Attribute  
3.5.3.9 DATA_HEADER_FORMAT Attribute  
3.5.3.10 CONVEYANCE Attribute   
3.5.3.11 Other Attributes   
3.6 Message Sequence Examples   
3.6.1 Stream Initiation   
3.6.2 Refusal to Initiate a Stream  
3.6.3 Stream Shutdown  
3.6.4 Uses of the STATUS command  
3.6.5 Use of the FLOW_CONTROL Command  
3.7 Session Management Error Conditions and Recovery   
3.7.1 Message Loss  
3.7.2 Session Management Protocol Congestion Management  
3.7.3 Session Management Protocol Non-Compliance   
3.8 Rules for Session Management  
3.8.1 Optional Features  
3.8.2 Attribute Related Rules  
3.8.3 Rules Related to Virtual Stream Status  
3.8.4 Rules Related to Vendor-Specific Commands   
3.8.5 Rules Related to Reserved Fields   
3.9 Notes on Optional Features and Inter-Operability  
3.9.1 Optional Attributes   
3.9.2 REQUEST and ADVERTISE   
# Chapter 4  Message Format Descriptions  
4.1 Introduction  
4.2 Control Message Formats   
4.2.1 REQUEST   
4.2.2 ADVERTISE   
4.2.3 OPEN  
4.2.4 ACCEPT  
4.2.5 REFUSE   
4.2.6 FLOW_CONTROL   
4.2.7 CLOSE  
4.2.8 STATUS   
4.2.9 User Defined  
4.3 Data Formats  
4.3.1 DATA Message Format, MAILBOX   
4.3.2 DATA1 Message Format, Large PDU   
4.3.3 DATA2 Message Format  
4.3.4 DATA3 Zero-length DATA header  
4.3.5 Data Streaming   
# Chapter 5  Registers  
5.1 Introduction  
5.2 Session Management Protocol Extended Features Register Block   
5.2.1 Session Management Protocol Register Block Header (Block Offset 0x0)   
5.2.2 Session Management Protocol Register Write Enable CSR  
(Block Offset 0x4)   
5.2.3 Session Management Advertisement CSR(Block Offset 0x8)  
5.2.4 Session Management Attribute Range CSR(Block Offset 0xC)   
5.2.5 Session Management Protocol Attributes 0-508 CSRs  
(Block Offset 0x10-0x7F8)  
5.3 Component Tag CSR Session Management Protocol Advertisement  
# Chapter 6  Vendor-Defined Protocols  
6.1 ProtoID  
6.2 Attributes   
6.2.1 VENDOR attribute   
6.2.2 PROTOCOL_NAME attribute   
6.2.3 Other attributes   
6.3 Other Requirements for Vendor-Defined Protocols   
# Chapter 7  Ethernet Encapsulation  
7.1 ProtoID  
7.2 Attributes   
7.2.1 MTU Attribute   
7.2.2 CONVEYANCE Attribute   
7.2.3 MAC_ADDRESS Attribute  
7.3 Other Requirements of Ethernet Encapsulation  
7.3.1 Dropped Messages  
7.3.2 Broadcast   
7.3.2.1 Broadcast With Multicast Extensions  
7.3.2.2 Broadcast Without Multicast Extensions  
7.3.2.3 Vendor defined Broadcast Server  
7.3.3 Ingress/Egress Nodes  
  
